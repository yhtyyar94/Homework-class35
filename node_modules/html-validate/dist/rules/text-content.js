"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dom_1 = require("../dom");
const rule_1 = require("../rule");
const meta_1 = require("../meta");
const helper_1 = require("./helper");
const text_1 = require("./helper/text");
const a17y_1 = require("./helper/a17y");
/**
 * Check if attribute is present and non-empty or dynamic.
 */
function hasNonEmptyAttribute(node, key) {
    const attr = node.getAttribute(key);
    return Boolean(attr && attr.valueMatches(/.+/, true));
}
/**
 * Check if element has default text.
 *
 * Only <input type="submit"> and <input type="reset"> at the moment.
 */
function hasDefaultText(node) {
    /* only input element have default text */
    if (!node.is("input")) {
        return false;
    }
    /* default text is not available if value attribute is present */
    if (node.hasAttribute("value")) {
        return false;
    }
    /* default text is only present when type is submit or reset */
    const type = node.getAttribute("type");
    return Boolean(type && type.valueMatches(/submit|reset/, false));
}
function isTextNode(node) {
    return node.nodeType === dom_1.NodeType.TEXT_NODE;
}
function isNonEmptyText(node) {
    if (isTextNode(node)) {
        return node.isDynamic || node.textContent.trim() !== "";
    }
    else {
        return false;
    }
}
/**
 * Walk nodes (depth-first, preorder) searching for accessible text. Children
 * hidden from accessibility tree are ignored.
 *
 * For each node the current conditions satisfies as accessible text:
 *
 * - Non-empty or dynamic `aria-label`
 * - Non-empty or dynamic `aria-labelledby` (reference not validated, use [[no-missing-references]]
 * - Image with non-empty or dynamic `alt` text
 * - Elements with default text
 */
function haveAccessibleText(node) {
    if (!a17y_1.inAccessibilityTree(node)) {
        return false;
    }
    /* check direct descendants for non-empty or dynamic text */
    const haveText = node.childNodes.some((child) => isNonEmptyText(child));
    if (haveText) {
        return true;
    }
    if (hasNonEmptyAttribute(node, "aria-label")) {
        return true;
    }
    if (hasNonEmptyAttribute(node, "aria-labelledby")) {
        return true;
    }
    if (node.is("img") && hasNonEmptyAttribute(node, "alt")) {
        return true;
    }
    if (hasDefaultText(node)) {
        return true;
    }
    return node.childElements.some((child) => {
        return haveAccessibleText(child);
    });
}
class TextContent extends rule_1.Rule {
    documentation(context) {
        const doc = {
            description: `The textual content for this element is not valid.`,
            url: rule_1.ruleDocumentationUrl(__filename),
        };
        if (context === null || context === void 0 ? void 0 : context.textContent) {
            switch (context.textContent) {
                case meta_1.TextContent.NONE:
                    doc.description = `The \`<${context.tagName}>\` element must not have textual content.`;
                    break;
                case meta_1.TextContent.REQUIRED:
                    doc.description = `The \`<${context.tagName}>\` element must have textual content.`;
                    break;
                case meta_1.TextContent.ACCESSIBLE:
                    doc.description = `The \`<${context.tagName}>\` element must have accessible text.`;
                    break;
            }
        }
        return doc;
    }
    static filter(event) {
        const { target } = event;
        /* skip elements without metadata */
        if (!target.meta) {
            return false;
        }
        /* skip elements without explicit and default textContent */
        const { textContent } = target.meta;
        if (!textContent || textContent === meta_1.TextContent.DEFAULT) {
            return false;
        }
        return true;
    }
    setup() {
        this.on("element:ready", TextContent.filter, (event) => {
            const { target } = event;
            const { textContent } = target.meta;
            switch (textContent) {
                case meta_1.TextContent.NONE:
                    this.validateNone(target);
                    break;
                case meta_1.TextContent.REQUIRED:
                    this.validateRequired(target);
                    break;
                case meta_1.TextContent.ACCESSIBLE:
                    this.validateAccessible(target);
                    break;
            }
        });
    }
    /**
     * Validate element has empty text (inter-element whitespace is not considered text)
     */
    validateNone(node) {
        if (helper_1.classifyNodeText(node) === text_1.TextClassification.EMPTY_TEXT) {
            return;
        }
        this.reportError(node, `${node.annotatedName} must not have text content`);
    }
    /**
     * Validate element has any text (inter-element whitespace is not considered text)
     */
    validateRequired(node) {
        if (helper_1.classifyNodeText(node) !== text_1.TextClassification.EMPTY_TEXT) {
            return;
        }
        this.reportError(node, `${node.annotatedName} must have text content`);
    }
    /**
     * Validate element has accessible text (either regular text or text only
     * exposed in accessibility tree via aria-label or similar)
     */
    validateAccessible(node) {
        /* skip this element if the element isn't present in accessibility tree */
        if (!a17y_1.inAccessibilityTree(node)) {
            return;
        }
        /* if the element or a child has aria-label, alt or default text, etc the
         * element has accessible text */
        if (haveAccessibleText(node)) {
            return;
        }
        this.reportError(node, `${node.annotatedName} must have accessible text`);
    }
    reportError(node, message) {
        var _a;
        this.report(node, message, null, {
            tagName: node.tagName,
            textContent: (_a = node.meta) === null || _a === void 0 ? void 0 : _a.textContent,
        });
    }
}
exports.default = TextContent;
